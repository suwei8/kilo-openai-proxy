# Kilo OpenAI Proxy — 开发记录（2025-09-02）

* 它聚焦这次修复后的**可运行状态、关键改动、验证方法、回滚要点与已知风险**，方便日后对比及回退。
## 版本快照

* 建议语义版本：`v0.1.1`
* 主要变更类型：`fix(sse)`（流式响应稳定性）
* 关键文件：`server.js`、`test/test_stream.mjs`
* 新增/临时调试路由：`GET /peek`（支持 `?base=`）

> 注：`.env` 未纳入版本控制（已在 `.gitignore`），以下仅记录关键项与推荐值。

---

## 当前能力（特性）

* 打包 **Gemini WebUI** 为 **OpenAI 兼容接口**

  * `POST /v1/chat/completions`（支持 `stream: true/false`）
  * `GET /v1/models`
* 浏览器持久化（Playwright Persistent Context）：登录态保存在 `.userdata/`
* 健康/调试路由：

  * `GET /healthz`、`GET /status`、`POST /reset`、`GET /debug`
  * `GET /peek?base=<number>`：调试用，返回当前可抓取文本片段与气泡数

---

## 环境与配置（当前有效）

* Node.js：20.x
* Playwright Chromium：build 1181（by Playwright）
* 运行配置（`.env`）要点：

  ```
  PORT=8033
  HEADLESS=false
  USER_DATA_DIR=.userdata
  GEMINI_URL=https://gemini.google.com/app
  WAIT_READY_MS=1500~2000
  MAX_ANSWER_MS=120000~180000
  STABLE_MS=800
  FORCE_ENTER_ONLY=false
  ```

  * `FORCE_ENTER_ONLY=false`：允许“按钮兜底”，回车提交失效时仍能触发生成
  * `STABLE_MS=800`：更稳地判定“生成完成”

---

## 这次关键修复（SSE 第二次请求复读上一次回答）

### 背景问题

* 现象：在 **SSE** 下连续两次调用，第二次会“复读第一次回答”。
* 根因：

  1. 读取器没有**基线（baseline）**，会先读到页面上“上一条的最后一个气泡”。
  2. 提交后即使**未触发生成**，旧行为也会继续读到上一次答案。

### 解决方案（核心思路）

1. **submitPrompt() 返回 baseline**：记录提交前消息气泡数量 `beforeCount`。

   * 若提交后检测不到“开始生成”（气泡数增加或最后一条出现文本），抛出 `submit_not_started`，避免误读旧内容。
2. **grabAnswerText(baseline)**：只读取 **baseline 之后新出现的最后一个气泡**；未出现新气泡时返回空串（不再回退 `aria-live`）。
3. **readAnswerInChunks(baseline)** 与 **waitForFinalAnswer(baseline)**：完整贯通 **baseline**。
4. 路由：`/v1/chat/completions` 在流式/非流式分支均**传入 baseline**，并在分支末尾 `return`。

### 影响面

* 修复了“第二次 SSE 复读”的核心问题。
* 未触发生成时会返回 `502 submit_not_started` 或 `no_text_captured`（可重试的错误）。

---

## 代码层改动清单

* `server.js`

  * `submitPrompt(prompt)`

    * 记录 `beforeCount` 并 **return baseline**
    * 回车连按；允许按钮兜底；未开始抛 `submit_not_started`
  * `grabAnswerText(baseline=0)`

    * 仅读取 baseline 之后的新气泡；滚动触发渲染；**不再回退 aria-live**
  * `readAnswerInChunks(baseline=0)`

    * 使用 `grabAnswerText(baseline)`；`STABLE_MS` 稳定窗判定
  * `waitForFinalAnswer(baseline=0)`

    * 同上；若从未得到文本则抛 `no_text_captured`
  * 路由 `/v1/chat/completions`

    * `const baseline = await submitPrompt(prompt)`
    * 流式与非流式分支均 **传 baseline**；分支末尾 `return`
  * 临时调试路由 `/peek?base=`（可开关）
  * `ensureBrowser()` 轻微健壮性：确保 `page` 可用
* `test/test_stream.mjs`

  * 保持原逻辑；用于验证连续两次提问

---

## 接口契约（当前）

### `POST /v1/chat/completions`

* 请求体（非流式）

  ```json
  {
    "model": "gemini-webui",
    "messages": [{"role":"user","content":"自检：请输出 OK"}],
    "stream": false
  }
  ```
* 请求体（流式）

  ```json
  {
    "model": "gemini-webui",
    "messages": [{"role":"user","content":"自检：请输出 OK（流式）"}],
    "stream": true
  }
  ```
* 返回

  * 非流式：OpenAI 兼容对象
  * 流式：`data: {...}\n\n` 增量 + `data: [DONE]\n\n` 收尾
* 可能错误（用于上层重试/监控）

  * `502 submit_not_started`：提交未触发生成（焦点/按钮/网络）
  * `502 no_text_captured`：已开始但抓取不到文本（渲染/DOM 改动）

---

## 验证步骤（回归用）

1. **健康检查**

   * `GET /healthz` → `{ ok: true }`
   * `GET /debug` → `answerArea.root:true` 或 `markdown:true` **至少其一为 true**
2. **非流式**

   * `node test_once.mjs`（提问 A）→ 返回 A 的答案
   * 立即再次运行（提问 B）→ 返回 B 的答案
3. **流式（SSE）**

   * `node test_stream.mjs`（提问 A）→ 流式输出 A
   * 立即再次运行（提问 B）→ 流式输出 B（不复读 A）
4. **调试（可选）**

   * 第二次请求前记下 `bubbles`，发起后：`GET /peek?base=<bubbles>` → 仅出现 B 的片段

---

## 已知风险与规避

* **页面 DOM 变更**：Gemini UI 更新可能导致选择器失效

  * 规避：`/debug` 检查 `answerArea.root/markdown`；适度放宽选择器或增加 Fallback
* **长回答截断**：受 `MAX_ANSWER_MS` 限制

  * 规避：适度增大 `MAX_ANSWER_MS`；生产建议使用 `stream:true`
* **并发仅单飞**：`busy` 保护一次只处理一个请求

  * 如需并发：后续可引入队列或多页/多 Context

---

## 回滚指引

* 目标：回滚到 **修复前版本**（无 baseline；可能复读）
* 操作（示例）：

  ```bash
  # 回滚单文件（若使用 Git）
  git checkout <old_tag_or_commit> -- server.js
  # 或直接回到旧标签
  git checkout v0.1.0
  ```
* 回滚影响：SSE 连续两次调用可能复现“复读上一次回答”

---

## 后续改进（Backlog）

* 增加 **多并发队列化**（页池/Page Pool 或多 Context）
* `/peek` 加开关（`DEBUG=1` 才暴露）并输出结构化 DOM 快照
* 端到端监控（统计 `submit_not_started` 比例、平均 `STABLE_MS` 停止时间）
* 适配更多 WebUI 版本的通用选择器集

---

## 本次提交信息（已采用）

```
fix(sse): 基于 baseline 阻止复读上一次回答，并贯通流式/非流式读取器

变更点：
- submitPrompt() 返回 beforeCount 作为 baseline，并在未开始生成时抛出 submit_not_started；回车连按并保留按钮兜底。
- grabAnswerText(baseline) 只读取 baseline 之后新增的最后一条消息气泡，滚动触发渲染；为避免复读，未出现新气泡时不再回退 aria-live。
- readAnswerInChunks(baseline)、waitForFinalAnswer(baseline) 全量贯通 baseline；稳定窗使用 STABLE_MS（推荐 800ms）。
- /v1/chat/completions 在流式与非流式分支中均传入 baseline，并在分支末尾显式 return。
- 新增 /peek?base= 调试能力，便于核对本次提交的基线与抓取文本。
- 小幅健壮性：ensureBrowser/newPage 防御；try/catch 花括号结构修正。
```

---

> 备注：如果你希望，我可以把这份文档直接生成到仓库里（文件名我建议用 `docs/dev-log-2025-09-02.md`），并补一条 `CHANGELOG.md` 的条目，方便和下一次迭代串起来。
